{"ast":null,"code":"import _asyncToGenerator from \"/Users/bovornpoljiturai/Numerical-method/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _regeneratorRuntime from \"/Users/bovornpoljiturai/Numerical-method/node_modules/@babel/runtime/regenerator/index.js\";\nimport { compile, derivative } from 'mathjs';\n\nvar Algebrite = require('algebrite');\n\nvar getXL_XR_from_API = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n    var response;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return fetch(\"http://localhost:5004/api/function_LR\").then(function (res) {\n              // console.log(res.json());\n              return res.json();\n            });\n\n          case 2:\n            response = _context.sent;\n            return _context.abrupt(\"return\", response);\n\n          case 4:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function getXL_XR_from_API() {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nvar func = function func(fx, X) {\n  var expr = compile(fx); // f(x)\n\n  var scope = {\n    x: parseFloat(X)\n  }; //f(x) ; x=input\n\n  return expr.evaluate(scope);\n};\n\nvar funcDiff = function funcDiff(fx, X) {\n  var expr = derivative(fx, 'x');\n  var scope = {\n    x: parseFloat(X)\n  };\n  return expr.evaluate(scope);\n};\n\nvar funcDiffDegreeN = function funcDiffDegreeN(fx, X, degree) {\n  var temp = fx,\n      expr;\n\n  for (var i = 1; i <= degree; i++) {\n    temp = derivative(temp, 'x');\n    expr = temp;\n  }\n\n  var scope = {\n    x: parseFloat(X)\n  };\n  return expr.evaluate(scope);\n};\n\nvar error = function error(xnew, xold) {\n  return Math.abs((xnew - xold) / xnew);\n};\n\nvar exactIntegrate = function exactIntegrate(fx, a, b) {\n  var expr = compile(Algebrite.integral(Algebrite.eval(fx)).toString());\n  return expr.evaluate({\n    x: b\n  }) - expr.evaluate({\n    x: a\n  });\n};\n\nexport { getXL_XR_from_API, func, funcDiff, funcDiffDegreeN, error, exactIntegrate };","map":{"version":3,"sources":["/Users/bovornpoljiturai/Numerical-method/src/services/Services.js"],"names":["compile","derivative","Algebrite","require","getXL_XR_from_API","fetch","then","res","json","response","func","fx","X","expr","scope","x","parseFloat","evaluate","funcDiff","funcDiffDegreeN","degree","temp","i","error","xnew","xold","Math","abs","exactIntegrate","a","b","integral","eval","toString"],"mappings":";;AAAA,SAASA,OAAT,EAAkBC,UAAlB,QAAoC,QAApC;;AACA,IAAIC,SAAS,GAAGC,OAAO,CAAC,WAAD,CAAvB;;AAEA,IAAMC,iBAAiB;AAAA,sEAAG;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBACCC,KAAK,CAAC,uCAAD,CAAL,CAA+CC,IAA/C,CAAoD,UAAAC,GAAG,EAAI;AAC/E;AACC,qBAAOA,GAAG,CAACC,IAAJ,EAAP;AACH,aAHsB,CADD;;AAAA;AAChBC,YAAAA,QADgB;AAAA,6CAKfA,QALe;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAAH;;AAAA,kBAAjBL,iBAAiB;AAAA;AAAA;AAAA,GAAvB;;AASA,IAAMM,IAAI,GAAG,SAAPA,IAAO,CAACC,EAAD,EAAKC,CAAL,EAAW;AACpB,MAAIC,IAAI,GAAGb,OAAO,CAACW,EAAD,CAAlB,CADoB,CACI;;AACxB,MAAIG,KAAK,GAAG;AAAEC,IAAAA,CAAC,EAAEC,UAAU,CAACJ,CAAD;AAAf,GAAZ,CAFoB,CAEc;;AAClC,SAAOC,IAAI,CAACI,QAAL,CAAcH,KAAd,CAAP;AACH,CAJD;;AAKA,IAAMI,QAAQ,GAAG,SAAXA,QAAW,CAACP,EAAD,EAAKC,CAAL,EAAW;AACxB,MAAIC,IAAI,GAAGZ,UAAU,CAACU,EAAD,EAAK,GAAL,CAArB;AACA,MAAIG,KAAK,GAAG;AAACC,IAAAA,CAAC,EAACC,UAAU,CAACJ,CAAD;AAAb,GAAZ;AACA,SAAOC,IAAI,CAACI,QAAL,CAAcH,KAAd,CAAP;AACH,CAJD;;AAMA,IAAMK,eAAe,GAAG,SAAlBA,eAAkB,CAACR,EAAD,EAAKC,CAAL,EAAQQ,MAAR,EAAmB;AACvC,MAAIC,IAAI,GAAGV,EAAX;AAAA,MAAeE,IAAf;;AACA,OAAK,IAAIS,CAAC,GAAC,CAAX,EAAeA,CAAC,IAAEF,MAAlB,EAA2BE,CAAC,EAA5B,EAAgC;AAC5BD,IAAAA,IAAI,GAAGpB,UAAU,CAACoB,IAAD,EAAO,GAAP,CAAjB;AACAR,IAAAA,IAAI,GAAGQ,IAAP;AACH;;AAED,MAAIP,KAAK,GAAG;AAACC,IAAAA,CAAC,EAACC,UAAU,CAACJ,CAAD;AAAb,GAAZ;AACA,SAAOC,IAAI,CAACI,QAAL,CAAcH,KAAd,CAAP;AACH,CATD;;AAUA,IAAMS,KAAK,GAAG,SAARA,KAAQ,CAACC,IAAD,EAAOC,IAAP,EAAgB;AAC1B,SAAOC,IAAI,CAACC,GAAL,CAAS,CAACH,IAAI,GAAGC,IAAR,IAAgBD,IAAzB,CAAP;AACH,CAFD;;AAGA,IAAMI,cAAc,GAAG,SAAjBA,cAAiB,CAACjB,EAAD,EAAKkB,CAAL,EAAQC,CAAR,EAAc;AACjC,MAAIjB,IAAI,GAAGb,OAAO,CAACE,SAAS,CAAC6B,QAAV,CAAmB7B,SAAS,CAAC8B,IAAV,CAAerB,EAAf,CAAnB,EAAuCsB,QAAvC,EAAD,CAAlB;AACA,SAAOpB,IAAI,CAACI,QAAL,CAAc;AAACF,IAAAA,CAAC,EAACe;AAAH,GAAd,IAAuBjB,IAAI,CAACI,QAAL,CAAc;AAACF,IAAAA,CAAC,EAACc;AAAH,GAAd,CAA9B;AAEH,CAJD;;AAKA,SAASzB,iBAAT,EAA4BM,IAA5B,EAAkCQ,QAAlC,EAA4CC,eAA5C,EAA6DI,KAA7D,EAAoEK,cAApE","sourcesContent":["import { compile, derivative } from 'mathjs';\nvar Algebrite = require('algebrite');\n\nconst getXL_XR_from_API = async () => {\n    const response = await fetch(\"http://localhost:5004/api/function_LR\").then(res => {\n       // console.log(res.json());\n        return res.json();\n    })\n    return response;\n\n}\n\nconst func = (fx, X) => {\n    var expr = compile(fx); // f(x)\n    let scope = { x: parseFloat(X) }; //f(x) ; x=input\n    return expr.evaluate(scope);\n}\nconst funcDiff = (fx, X) => {\n    var expr = derivative(fx, 'x');\n    let scope = {x:parseFloat(X)};\n    return expr.evaluate(scope); \n}\n\nconst funcDiffDegreeN = (fx, X, degree) => {\n    var temp = fx, expr;\n    for (var i=1 ; i<=degree ; i++) {\n        temp = derivative(temp, 'x')\n        expr = temp\n    }\n    \n    let scope = {x:parseFloat(X)}\n    return expr.evaluate(scope)\n}\nconst error = (xnew, xold) => {\n    return Math.abs((xnew - xold) / xnew);\n}\nconst exactIntegrate = (fx, a, b) => {\n    var expr = compile(Algebrite.integral(Algebrite.eval(fx)).toString())\n    return expr.evaluate({x:b}) - expr.evaluate({x:a})\n\n}\nexport { getXL_XR_from_API, func, funcDiff, funcDiffDegreeN, error, exactIntegrate };"]},"metadata":{},"sourceType":"module"}