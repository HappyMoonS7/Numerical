{"ast":null,"code":"import _regeneratorRuntime from \"/Users/bovornpoljiturai/Desktop/Numerical-method(CSB)/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/bovornpoljiturai/Desktop/Numerical-method(CSB)/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { compile, derivative } from 'mathjs';\n\nvar Algebrite = require('algebrite');\n\nconst getXL_XR_from_API = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n    var response;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          _context.next = 2;\n          return fetch(\"http://localhost:5004/api/function_LR\").then(res => {\n            // console.log(res.json());\n            return res.json();\n          });\n\n        case 2:\n          response = _context.sent;\n          return _context.abrupt(\"return\", response);\n\n        case 4:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n\n  return function getXL_XR_from_API() {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nconst func = (fx, X) => {\n  var expr = compile(fx); // f(x)\n\n  let scope = {\n    x: parseFloat(X)\n  }; //f(x) ; x=input\n\n  return expr.evaluate(scope);\n};\n\nconst funcDiff = (fx, X) => {\n  var expr = derivative(fx, 'x');\n  let scope = {\n    x: parseFloat(X)\n  };\n  return expr.evaluate(scope);\n};\n\nconst funcDiffDegreeN = (fx, X, degree) => {\n  var temp = fx,\n      expr;\n\n  for (var i = 1; i <= degree; i++) {\n    temp = derivative(temp, 'x');\n    expr = temp;\n  }\n\n  let scope = {\n    x: parseFloat(X)\n  };\n  return expr.evaluate(scope);\n};\n\nconst error = (xnew, xold) => {\n  return Math.abs((xnew - xold) / xnew);\n};\n\nconst exactIntegrate = (fx, a, b) => {\n  var expr = compile(Algebrite.integral(Algebrite.eval(fx)).toString());\n  return expr.evaluate({\n    x: b\n  }) - expr.evaluate({\n    x: a\n  });\n};\n\nexport { getXL_XR_from_API, func, funcDiff, funcDiffDegreeN, error, exactIntegrate };","map":{"version":3,"sources":["/Users/bovornpoljiturai/Desktop/Numerical-method(CSB)/src/services/Services.js"],"names":["compile","derivative","Algebrite","require","getXL_XR_from_API","fetch","then","res","json","response","func","fx","X","expr","scope","x","parseFloat","evaluate","funcDiff","funcDiffDegreeN","degree","temp","i","error","xnew","xold","Math","abs","exactIntegrate","a","b","integral","eval","toString"],"mappings":";;AAAA,SAASA,OAAT,EAAkBC,UAAlB,QAAoC,QAApC;;AACA,IAAIC,SAAS,GAAGC,OAAO,CAAC,WAAD,CAAvB;;AAEA,MAAMC,iBAAiB;AAAA,sEAAG;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,iBACCC,KAAK,CAAC,uCAAD,CAAL,CAA+CC,IAA/C,CAAoDC,GAAG,IAAI;AAC/E;AACC,mBAAOA,GAAG,CAACC,IAAJ,EAAP;AACH,WAHsB,CADD;;AAAA;AAChBC,UAAAA,QADgB;AAAA,2CAKfA,QALe;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAAH;;AAAA,kBAAjBL,iBAAiB;AAAA;AAAA;AAAA,GAAvB;;AASA,MAAMM,IAAI,GAAG,CAACC,EAAD,EAAKC,CAAL,KAAW;AACpB,MAAIC,IAAI,GAAGb,OAAO,CAACW,EAAD,CAAlB,CADoB,CACI;;AACxB,MAAIG,KAAK,GAAG;AAAEC,IAAAA,CAAC,EAAEC,UAAU,CAACJ,CAAD;AAAf,GAAZ,CAFoB,CAEc;;AAClC,SAAOC,IAAI,CAACI,QAAL,CAAcH,KAAd,CAAP;AACH,CAJD;;AAKA,MAAMI,QAAQ,GAAG,CAACP,EAAD,EAAKC,CAAL,KAAW;AACxB,MAAIC,IAAI,GAAGZ,UAAU,CAACU,EAAD,EAAK,GAAL,CAArB;AACA,MAAIG,KAAK,GAAG;AAACC,IAAAA,CAAC,EAACC,UAAU,CAACJ,CAAD;AAAb,GAAZ;AACA,SAAOC,IAAI,CAACI,QAAL,CAAcH,KAAd,CAAP;AACH,CAJD;;AAMA,MAAMK,eAAe,GAAG,CAACR,EAAD,EAAKC,CAAL,EAAQQ,MAAR,KAAmB;AACvC,MAAIC,IAAI,GAAGV,EAAX;AAAA,MAAeE,IAAf;;AACA,OAAK,IAAIS,CAAC,GAAC,CAAX,EAAeA,CAAC,IAAEF,MAAlB,EAA2BE,CAAC,EAA5B,EAAgC;AAC5BD,IAAAA,IAAI,GAAGpB,UAAU,CAACoB,IAAD,EAAO,GAAP,CAAjB;AACAR,IAAAA,IAAI,GAAGQ,IAAP;AACH;;AAED,MAAIP,KAAK,GAAG;AAACC,IAAAA,CAAC,EAACC,UAAU,CAACJ,CAAD;AAAb,GAAZ;AACA,SAAOC,IAAI,CAACI,QAAL,CAAcH,KAAd,CAAP;AACH,CATD;;AAUA,MAAMS,KAAK,GAAG,CAACC,IAAD,EAAOC,IAAP,KAAgB;AAC1B,SAAOC,IAAI,CAACC,GAAL,CAAS,CAACH,IAAI,GAAGC,IAAR,IAAgBD,IAAzB,CAAP;AACH,CAFD;;AAGA,MAAMI,cAAc,GAAG,CAACjB,EAAD,EAAKkB,CAAL,EAAQC,CAAR,KAAc;AACjC,MAAIjB,IAAI,GAAGb,OAAO,CAACE,SAAS,CAAC6B,QAAV,CAAmB7B,SAAS,CAAC8B,IAAV,CAAerB,EAAf,CAAnB,EAAuCsB,QAAvC,EAAD,CAAlB;AACA,SAAOpB,IAAI,CAACI,QAAL,CAAc;AAACF,IAAAA,CAAC,EAACe;AAAH,GAAd,IAAuBjB,IAAI,CAACI,QAAL,CAAc;AAACF,IAAAA,CAAC,EAACc;AAAH,GAAd,CAA9B;AAEH,CAJD;;AAKA,SAASzB,iBAAT,EAA4BM,IAA5B,EAAkCQ,QAAlC,EAA4CC,eAA5C,EAA6DI,KAA7D,EAAoEK,cAApE","sourcesContent":["import { compile, derivative } from 'mathjs';\nvar Algebrite = require('algebrite');\n\nconst getXL_XR_from_API = async () => {\n    const response = await fetch(\"http://localhost:5004/api/function_LR\").then(res => {\n       // console.log(res.json());\n        return res.json();\n    })\n    return response;\n\n}\n\nconst func = (fx, X) => {\n    var expr = compile(fx); // f(x)\n    let scope = { x: parseFloat(X) }; //f(x) ; x=input\n    return expr.evaluate(scope);\n}\nconst funcDiff = (fx, X) => {\n    var expr = derivative(fx, 'x');\n    let scope = {x:parseFloat(X)};\n    return expr.evaluate(scope); \n}\n\nconst funcDiffDegreeN = (fx, X, degree) => {\n    var temp = fx, expr;\n    for (var i=1 ; i<=degree ; i++) {\n        temp = derivative(temp, 'x')\n        expr = temp\n    }\n    \n    let scope = {x:parseFloat(X)}\n    return expr.evaluate(scope)\n}\nconst error = (xnew, xold) => {\n    return Math.abs((xnew - xold) / xnew);\n}\nconst exactIntegrate = (fx, a, b) => {\n    var expr = compile(Algebrite.integral(Algebrite.eval(fx)).toString())\n    return expr.evaluate({x:b}) - expr.evaluate({x:a})\n\n}\nexport { getXL_XR_from_API, func, funcDiff, funcDiffDegreeN, error, exactIntegrate };"]},"metadata":{},"sourceType":"module"}